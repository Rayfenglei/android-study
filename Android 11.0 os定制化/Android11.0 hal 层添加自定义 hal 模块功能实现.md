> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/baidu_41666295/article/details/132383883)

1. 前言
-----

在 11.0 的系统 rom 定制化开发中，在 对 [hal](https://so.csdn.net/so/search?q=hal&spm=1001.2101.3001.7020) 模块进行开发时，需要通过添加自定义的 hal 模块来实现某些功能时，就需要添加 hal 模块的相关功能，接下来就来实现一个案例来供参考

2.hal 层添加自定义 hal 模块功能实现的核心类
---------------------------

```
hardware\interfaces\

```

3.hal 层添加自定义 hal 模块功能实现的核心功能分析和实现
---------------------------------

[HIDL](https://so.csdn.net/so/search?q=HIDL&spm=1001.2101.3001.7020) 的全称是 HAL interface definition language（硬件抽象层接口定义语言），在此之前 Android 有 AIDL，  
架构在 Android binder 之上，用来定义 Android 基于 Binder 通信的 Client 与 Service 之间的接口。  
HIDL 也是类似的作用，只不过定义的是 Android Framework 与 Android HAL 实现之间的接口。

HIDL 可以分为：HIDL C++(C++ 实现)、HIDL Java(Java 实现)，并且还主要分为直通式和绑定式，  
本篇文章使用的 C++ 和直通式的 HIDL 实现了 上述的功能，  
HAL 是硬件抽象层，它向下屏蔽了硬件的实现细节，向上提供了抽象接口，  
HAL 是底层硬件和上层框架直接的接口，框架层通过 HAL 可以操作硬件设备  
HAL 和内核驱动，HAL 实现在用户空间，驱动在内核空间，所以为了维护各大厂商  
的利益，核心算法之类的就需要在 hal 层实现了

Android 系统的硬件抽象层（Hardware Abstract Layer, HAL）运行在用户空间中，它向下屏蔽硬件驱动模块的实现细节，向上提供硬件访问服务。通过硬件抽象层，Android 系统分为两层来支持硬件设备，其中一层实现在用户空间（User Space），另外一层是现在内核空间（Kernel Space）。传统的 Linux 系统把对硬件的支持完全是现在在内核空间，即把对硬件的支持完全实现在硬件驱动模块中。  
首先在 hardware\interfaces 下仿造其他 hal 模块建立 test_hidl 文件夹  
然后创建 ITest.hal 提供 jni 调用的接口

```
   hardware\interfaces\test_hidl\1.0\ITest.hal
    package android.hardware.test_hidl@1.0;
     
    interface ITest {
     
        addition_hidl(int32_t a,int32_t b) generates (int32_t total);
        
    };
```

在上述的 ITest.hal 这个文件定义了一个 addition_hidl 函数，这个函数用来调用 HAL 的加法函数  
然后就可以使用 Android 提供的工具 hidl-gen 来生成 HIDL 框架，执行如下命令：

```
    PACKAGE=android.hardware.test_hidl@1.0
     LOC=hardware/interfaces/test_hidl/1.0/default/
     hidl-gen -o $LOC -Lc++-impl -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport $PACKAGE
     hidl-gen -o $LOC -Landroidbp-impl -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport $PACKAGE
```

执行命令成功之后我们会发现 hardware/interfaces/test_hidl/1.0 下多了一个 default 目录，  
进入 default 目录，里面有三个文件 Android.bp，Test.cpp，Test.h

```
  hardware\interfaces\test_hidl\1.0\Android.bp
    // This file is autogenerated by hidl-gen -Landroidbp.
     
    hidl_interface {
        name: "android.hardware.test_hidl@1.0",
        root: "android.hardware",
        vndk: {
            enabled: true,
        },
        srcs: [
            "IHello.hal",
        ],
        interfaces: [
            "android.hidl.base@1.0",
        ],
        gen_java: true,
    }
     
    hardware\interfaces\test_hidl\1.0\default\Android.bp
    // FIXME: your file license if you have one
     
    cc_library_shared {
 
        name: "android.hardware.test_hidl@1.0-impl",
        relative_install_path: "hw",
        // FIXME: this should be 'vendor: true' for modules that will eventually be
        // on AOSP.
        proprietary: true,
        srcs: [
            "Test.cpp",
        ],
    	cflags: [
    	    "-Wno-unused-parameter",
    	],
        shared_libs: [
            "libhidlbase",
            "libhidltransport",
            "libutils",
            "android.hardware.test_hidl@1.0",
        ],
    }
     
    cc_binary {
        name: "android.hardware.test_hidl@1.0-service",
        defaults: ["hidl_defaults"],
        relative_install_path: "hw",
        vendor: true,
        srcs: ["service.cpp"],
        shared_libs: [
            "android.hardware.test_hidl@1.0",
            "libhardware",
            "libhidlbase",
            "libhidltransport",
            "libutils",
            "liblog",
        ],
     
    }
     
    hardware\interfaces\test_hidl\1.0\default\Test.cpp
    // FIXME: your file license if you have one
     
    #include "Test.h"
    namespace android {
    namespace hardware {
    namespace test_hidl {
    namespace V1_0 {
    namespace implementation {
     
    // Methods from ::android::hardware::hello_hidl::V1_0::IHello follow.
    Return<int32_t> Test::addition_hidl(int32_t a, int32_t b) {
        // TODO implement
        return int32_t {};
    }
     
     
    // Methods from ::android::hidl::base::V1_0::IBase follow.
     
    ITest* HIDL_FETCH_IHello(const char* /* name */) {
        return new Test();
    }
    //
    }  // namespace implementation
    }  // namespace V1_0
    }  // namespace test_hidl
    }  // namespace hardware
    }  // namespace android
     
    hardware\interfaces\test_hidl\1.0\default\Test.h
    // FIXME: your file license if you have one
     
    #pragma once
     
    #include <android/hardware/test_hidl/1.0/ITest.h>
    #include <hidl/MQDescriptor.h>
    #include <hidl/Status.h>
     
    namespace android {
    namespace hardware {
    namespace test_hidl {
    namespace V1_0 {
    namespace implementation {
     
    using ::android::hardware::hidl_array;
    using ::android::hardware::hidl_memory;
    using ::android::hardware::hidl_string;
    using ::android::hardware::hidl_vec;
    using ::android::hardware::Return;
    using ::android::hardware::Void;
    using ::android::sp;
     
    struct Hello : public ITest {
        // Methods from ::android::hardware::test_hidl::V1_0::ITest follow.
        Return<int32_t> addition_hidl(int32_t a, int32_t b) override;
     
        // Methods from ::android::hidl::base::V1_0::IBase follow.
     
    };
     
    // FIXME: most likely delete, this is only for passthrough implementations
     extern "C" ITest* HIDL_FETCH_ITest(const char* name);
     
    }  // namespace implementation
    }  // namespace V1_0
    }  // namespace test_hidl
    }  // namespace hardware
    }  // namespace android
```

接着我们还需要在 default 目录下增加一个空文件 service.cpp，用作注册 HIDL 服务，  
我们采用直通式的 HIDL，所以 service.cpp 的内容为：

```
   hardware\interfaces\test_hidl\1.0\default\service.cpp
    #include <android/hardware/hello_hidl/1.0/ITest.h>
    #include <hidl/LegacySupport.h>
    // Generated HIDL files
    using android::hardware::test_hidl::V1_0::ITest;
    using android::hardware::defaultPassthroughServiceImplementation;
     
    int main() {
        return defaultPassthroughServiceImplementation<ITest>();
    }
```

defaultPassthroughServiceImplementation 函数最终会向 HwServiceManager 注册 HIDL 服务

然后把 android.hardware.test_hidl@1.0-impl  android.hardware.test_hidl@1.0-service  
android.hardware.test_hidl@1.0 参与到系统编译，如果是 framework 层调用 需要把  
android.hardware.test_hidl@1.0 放到 framework/base/service/core/jni 下的 Android.bp 中  
然后在编译后，会出现 error:VNDK library list has been changed 的错误解决

对于在 10.0 中 添加 hal 的 aidl 服务中编译的错误的修改  
上述错误的大致意思是 build/make/target/product/gsi/29.txt out/target/product/evk_8mq/obj/PACKAGING/vndk_intermediates/libs.txt 这两个文件不相同，而 libs.txt 是自动生成的。它包含了最新增加的模块。而在 hal 中添加的 so 库模块没有添加的 29.txt 中 和 current.txt 中所以造成差异导致报错的

build/make/target/product/gsi/29.txt 和 build/make/target/product/gsi/current.txt 添加 VNDK-core: android.hardware.hello_hidl@1.0.so  
注意 记得按照字母排列顺序位置添加  
先搜索 out/target/product/evk_8mq/obj/PACKAGING/vndk_intermediates/libs.txt 下的 VNDK-core: android.hardware.hello_hidl@1.0.so 的位置  
然后在 build/make/target/product/gsi/29.txt 和 build/make/target/product/gsi/current.txt 中相同的位置 添加 VNDK-core: android.hardware.hello_hidl@1.0.so  
在编译就可以了